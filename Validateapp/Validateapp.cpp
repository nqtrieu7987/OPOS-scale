#include "stdafx.h" #include <string> #include "windows.h"#include <atlbase.h>#include <atlstr.h>#include <memory>CSimpleMap <std::wstring, std::wstring> m_RegistryData;#include "WinHttpClient.h"CSimpleMap <std::wstring,int> keylist;#include <tchar.h>#include <OposScal.hi>wchar_t m_OposRootKey[256];#define MAX_KEY_LENGTH 255#define MAX_VALUE_NAME 16383void CompleteTest(void){	// 1. Get the initial cookie.	WinHttpClient getClient(L"http://starcom.com.vn/licence.php");	//  getClient.SetAdditionalRequestHeaders(L"Accept: image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*\r\nAccept-Language: en-us\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; QQPinyin 730; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; InfoPath.2; CIBA; MS-RTC LM 8)\r\nAccept-Encoding: gzip, deflate\r\nProxy-Connection: Keep-Alive\r\nHost: www.codeproject.com\r\n");	if (!getClient.SendHttpRequest())	{		return;	}	std::wstring d = getClient.GetResponseContent();}  #include <iostream>#define INFO_BUFFER_SIZE 32767TCHAR  infoBuf[INFO_BUFFER_SIZE];DWORD  bufCharCount = INFO_BUFFER_SIZE;std::string ws2s(const std::wstring& s){	int len;	int slength = (int)s.length() + 1;	len = WideCharToMultiByte(CP_ACP, 0, s.c_str(), slength, 0, 0, 0, 0);	std::string r(len, '\0');	WideCharToMultiByte(CP_ACP, 0, s.c_str(), slength, &r[0], len, 0, 0);	return r;}std::wstring s2ws(const std::string& str){	using convert_typeX = std::codecvt_utf8<wchar_t>;	std::wstring_convert<convert_typeX, wchar_t> converterX;	return converterX.from_bytes(str);}void QueryKey(HKEY hKey) {     TCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name    DWORD    cbName;                   // size of name string     TCHAR    achClass[MAX_PATH] = TEXT("");  // buffer for class name     DWORD    cchClassName = MAX_PATH;  // size of class string     DWORD    cSubKeys=0;               // number of subkeys     DWORD    cbMaxSubKey;              // longest subkey size     DWORD    cchMaxClass;              // longest class string     DWORD    cValues;              // number of values for key     DWORD    cchMaxValue;          // longest value name     DWORD    cbMaxValueData;       // longest value data     DWORD    cbSecurityDescriptor; // size of security descriptor     FILETIME ftLastWriteTime;      // last write time      DWORD i, retCode;      TCHAR  achValue[MAX_VALUE_NAME];     DWORD cchValue = MAX_VALUE_NAME;      // Get the class name and the value count.     retCode = RegQueryInfoKey(        hKey,                    // key handle         achClass,                // buffer for class name         &cchClassName,           // size of class string         NULL,                    // reserved         &cSubKeys,               // number of subkeys         &cbMaxSubKey,            // longest subkey size         &cchMaxClass,            // longest class string         &cValues,                // number of values for this key         &cchMaxValue,            // longest value name         &cbMaxValueData,         // longest value data         &cbSecurityDescriptor,   // security descriptor         &ftLastWriteTime);       // last write time      // Enumerate the subkeys, until RegEnumKeyEx fails.        if (cSubKeys)    {               for (i=0; i<cSubKeys; i++)         {             cbName = MAX_KEY_LENGTH;            retCode = RegEnumKeyEx(hKey, i,                     achKey,                      &cbName,                      NULL,                      NULL,                      NULL,                      &ftLastWriteTime);             if (retCode == ERROR_SUCCESS)             {				keylist.Add(achKey, 0);             }        }    }      // Enumerate the key values.     if (cValues)     {        printf( "\nNumber of values: %d\n", cValues);        for (i=0, retCode=ERROR_SUCCESS; i<cValues; i++)         {             cchValue = MAX_VALUE_NAME;             achValue[0] = '\0';             retCode = RegEnumValue(hKey, i,                 achValue,                 &cchValue,                 NULL,                 NULL,                NULL,                NULL);             if (retCode == ERROR_SUCCESS )             {                 _tprintf(TEXT("(%d) %s\n"), i+1, achValue);             }         }    }}void SetTheRegistryKey (LPCWSTR DeviceClass, LPCWSTR DeviceName){ 	wsprintf (m_OposRootKey, L"%S\\%s\\%s", OPOS_ROOTKEY, DeviceClass, DeviceName);}	int ReadRegistry(void){	m_RegistryData.RemoveAll();	HKEY  hKey = 0;	//Scale CAS_1; 		LONG lRetVal = RegOpenKeyEx (HKEY_LOCAL_MACHINE, m_OposRootKey, 0, KEY_READ, &hKey);	if (lRetVal == ERROR_SUCCESS) {		DWORD  dwIndex = 0;		DWORD  dwType;		do {			wchar_t  wsValueName[128] = {0};			BYTE     wsValueValue[256] = {0};			DWORD  dwValueNameSize = 124, dwValueValueSize = sizeof(wsValueValue);			lRetVal = RegEnumValue (hKey, dwIndex, wsValueName, &dwValueNameSize, NULL, &dwType, wsValueValue, &dwValueValueSize);			if (dwValueNameSize > 0 && lRetVal == ERROR_SUCCESS) {				wsValueName[dwValueNameSize] = 0;				wsValueValue[dwValueValueSize] = wsValueValue[dwValueValueSize+1] = 0;				m_RegistryData.Add(std::wstring(wsValueName), std::wstring((wchar_t *)wsValueValue));			}			dwIndex++;		} while (lRetVal == ERROR_SUCCESS);		lRetVal = RegCloseKey (hKey);	}	return 0;}#include "md5.h"// Write the data to the registry from the data areas.int WriteKeyRegistry(wstring d)	{		HKEY  hKey = 0;		LONG lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, m_OposRootKey, 0, KEY_WRITE, &hKey);		if (lRetVal == ERROR_SUCCESS) {			DWORD  dwIndex = 0;			DWORD  dwType = REG_SZ;			int c = 0;			for (int iLoop = 0; iLoop < m_RegistryData.GetSize(); iLoop++) {				std::wstring j1 = m_RegistryData.GetKeyAt(iLoop);				std::wstring j2 = m_RegistryData.GetValueAt(iLoop);				if (j1 == L"DeviceName" && (j2.find(_T("ED"))  > 0 ||j2.find(_T("DBB")) > 0 ||j2.find(_T("DB")) > 0||j2.find(_T("PR")) > 0) )				{					c = 1;				}			}			if (c == 1)			{				std::wstring    data =  d;				DWORD  dwValueValueSize = (data.length() + 1) * sizeof(wchar_t);				LONG setRes = RegSetValueEx(hKey, L"token", NULL, REG_SZ, (BYTE *)data.c_str(), dwValueValueSize);			}			lRetVal = RegCloseKey(hKey);		}		return 0;	}int WriteRegistry(void){	HKEY  hKey = 0; 	LONG lRetVal = RegOpenKeyEx (HKEY_LOCAL_MACHINE, m_OposRootKey, 0, KEY_WRITE, &hKey);	if (lRetVal == ERROR_SUCCESS) {		DWORD  dwIndex = 0;		DWORD  dwType = REG_SZ;		int c=0;		for (int iLoop = 0; iLoop < m_RegistryData.GetSize (); iLoop++) {			std::wstring j1 = m_RegistryData.GetKeyAt(iLoop);			std::wstring j2 = m_RegistryData.GetValueAt(iLoop);  			if(j1==L"DeviceName" && j2.find(_T("ED"))>0  )			{				c=1;			} 		}if(c==1){	std::wstring    data = L"Scale.OPOS\0";	DWORD  dwValueValueSize = (data.length() + 1) * sizeof(wchar_t);	 LONG setRes = RegSetValueEx (hKey, L"", NULL, REG_SZ,  (BYTE *) data.c_str(),dwValueValueSize); }		lRetVal = RegCloseKey (hKey);	}	return 0;} #include <fstream>std::string& ltrim(std::string& str, const std::string& chars = "\t\n\v\f\r "){	str.erase(0, str.find_first_not_of(chars));	return str;}std::string& rtrim(std::string& str, const std::string& chars = "\t\n\v\f\r "){	str.erase(str.find_last_not_of(chars) + 1);	return str;}std::string& trim(std::string& str, const std::string& chars = "\t\n\v\f\r "){	return ltrim(rtrim(str, chars), chars);}#include <clocale>#include <locale>#include <vector>#include "HardDriveSerialNumer.h"#include <iostream>std::wstring s2ws(const std::string& str){    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);    std::wstring wstrTo( size_needed, 0 );    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);    return wstrTo;}int _tmain(int argc, _TCHAR* argv[]){ 	 	int out = 0,i=10;	MasterHardDiskSerial a;	char SerialNumber[1024] = {""}; 	memset(&SerialNumber,0,sizeof(SerialNumber));	out = a.GetSerialNo(SerialNumber); 	std::wifstream input("key.txt"); //The input stream	std::wstring key=L""; 	if (!input.fail()) {				std::getline(input, key);		input.close();	} 	else	{	  printf("can not find licence file");	} 	if(key.compare(_T(""))==0)	{	   printf("can not read licence file");	}   	std::wstring mac =s2ws(SerialNumber);	std::wstring s(L"http://starcom.com.vn/licence.php?MAC=");	s += std::wstring(mac);	s += std::wstring(L"&NAME=");	GetComputerName(infoBuf, &bufCharCount);	std::wstring computername(&infoBuf[0]); 	s += std::wstring(computername);	s += std::wstring(L"&CODE=");	s += key;	WinHttpClient getClient(s);  	if (!getClient.SendHttpRequest())	{			printf("can not connect to server!");		    return 0;	}	std::wstring d = getClient.GetResponseContent(); 	if (d.length()>10)	{	    printf("active success !");	 	}	else	{		printf("please contact to admin! error code ");		std::wcout<<d;		cin.get();		return 0;	}	  HKEY hTestKey;	  wchar_t m_OposRootKeytest[256];	  wsprintf (m_OposRootKeytest, L"%S\\%s", OPOS_ROOTKEY, _T("Scale"));    if(  RegOpenKeyEx (HKEY_LOCAL_MACHINE, m_OposRootKeytest, 0, KEY_READ, &hTestKey) == ERROR_SUCCESS   )   {      QueryKey(hTestKey);   }   RegCloseKey(hTestKey);   for (int i = 0; i < keylist.GetSize (); i++) {	  std::wstring j1 = keylist.GetKeyAt(i);	  // std::wcout<<d; 	   SetTheRegistryKey(_T("Scale"),j1.c_str()); 	   ReadRegistry();	   WriteKeyRegistry(d);	   WriteRegistry();   } 	cin.get();	return 0;}